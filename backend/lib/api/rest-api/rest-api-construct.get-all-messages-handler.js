"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = void 0;
const aws_sdk_1 = require("aws-sdk");
const sort_1 = require("../../util/sort");
const MAX_MESSAGES_LIMIT = 30;
const handler = async () => {
    const messagesTable = process.env.MESSAGES_TABLE_NAME || (() => {
        throw new Error('No messages table name supplied');
    })();
    console.log('Querying messages');
    const documentClient = new aws_sdk_1.DynamoDB.DocumentClient();
    const allMessages = (await documentClient.scan({ TableName: messagesTable }).promise()).Items;
    allMessages.sort((messageA, messageB) => (0, sort_1.sortByStringDesc)(messageA.sentAt, messageB.sentAt));
    let messagesToReturn;
    if (!allMessages) {
        messagesToReturn = [];
    }
    else if (allMessages.length > MAX_MESSAGES_LIMIT) {
        console.log('To many messages in table, deleting superfluous ones');
        await deleteSuperfluousMessages(allMessages, documentClient, messagesTable);
        messagesToReturn = allMessages.slice(0, MAX_MESSAGES_LIMIT);
    }
    else {
        messagesToReturn = allMessages;
    }
    console.log(`Retrieved latest messages`);
    return {
        statusCode: 200,
        body: JSON.stringify({ messages: messagesToReturn }),
        headers: { 'Access-Control-Allow-Origin': '*' }
    };
};
exports.handler = handler;
/**
 * Deletes all messages from the table that exceed the limit, leaving only the most recent ones
 * @param messagesSorted List of all message table rows, sorted in descending order by sentAt property
 * @param documentClient
 * @param messagesTable table name of messages table
 */
async function deleteSuperfluousMessages(messagesSorted, documentClient, messagesTable) {
    const messagesToDelete = messagesSorted.slice(MAX_MESSAGES_LIMIT, messagesSorted.length);
    console.log('Deleting ' + messagesToDelete.length + ' items');
    while (messagesToDelete.length > 0) {
        const currentBatch = messagesToDelete.splice(0, 25);
        await documentClient.batchWrite({
            RequestItems: {
                [messagesTable]: currentBatch.map(message => ({
                    DeleteRequest: { Key: { id: message.id } }
                }))
            }
        }).promise();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzdC1hcGktY29uc3RydWN0LmdldC1hbGwtbWVzc2FnZXMtaGFuZGxlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInJlc3QtYXBpLWNvbnN0cnVjdC5nZXQtYWxsLW1lc3NhZ2VzLWhhbmRsZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EscUNBQWlDO0FBQ2pDLDBDQUFpRDtBQUdqRCxNQUFNLGtCQUFrQixHQUFHLEVBQUUsQ0FBQTtBQUV0QixNQUFNLE9BQU8sR0FBRyxLQUFLLElBQXNDLEVBQUU7SUFDaEUsTUFBTSxhQUFhLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUMzRCxNQUFNLElBQUksS0FBSyxDQUFDLGlDQUFpQyxDQUFDLENBQUE7SUFDdEQsQ0FBQyxDQUFDLEVBQUUsQ0FBQTtJQUNKLE9BQU8sQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsQ0FBQztJQUNqQyxNQUFNLGNBQWMsR0FBRyxJQUFJLGtCQUFRLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDckQsTUFBTSxXQUFXLEdBQUcsQ0FBQyxNQUFNLGNBQWMsQ0FBQyxJQUFJLENBQUMsRUFBQyxTQUFTLEVBQUUsYUFBYSxFQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLEtBQTZCLENBQUM7SUFDcEgsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRSxRQUFRLEVBQUUsRUFBRSxDQUFDLElBQUEsdUJBQWdCLEVBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQTtJQUM1RixJQUFJLGdCQUFzQyxDQUFBO0lBQzFDLElBQUksQ0FBQyxXQUFXLEVBQUU7UUFDZCxnQkFBZ0IsR0FBRyxFQUFFLENBQUE7S0FDeEI7U0FBTSxJQUFJLFdBQVcsQ0FBQyxNQUFNLEdBQUcsa0JBQWtCLEVBQUU7UUFDaEQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxzREFBc0QsQ0FBQyxDQUFBO1FBQ25FLE1BQU0seUJBQXlCLENBQUMsV0FBVyxFQUFFLGNBQWMsRUFBRSxhQUFhLENBQUMsQ0FBQTtRQUMzRSxnQkFBZ0IsR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxrQkFBa0IsQ0FBQyxDQUFBO0tBQzlEO1NBQU07UUFDSCxnQkFBZ0IsR0FBRyxXQUFXLENBQUE7S0FDakM7SUFFRCxPQUFPLENBQUMsR0FBRyxDQUFDLDJCQUEyQixDQUFDLENBQUM7SUFFekMsT0FBTztRQUNILFVBQVUsRUFBRSxHQUFHO1FBQ2YsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBQyxRQUFRLEVBQUUsZ0JBQWdCLEVBQUMsQ0FBQztRQUNsRCxPQUFPLEVBQUUsRUFBQyw2QkFBNkIsRUFBRSxHQUFHLEVBQUM7S0FDaEQsQ0FBQztBQUVOLENBQUMsQ0FBQTtBQTNCWSxRQUFBLE9BQU8sV0EyQm5CO0FBRUQ7Ozs7O0dBS0c7QUFDSCxLQUFLLFVBQVUseUJBQXlCLENBQUMsY0FBb0MsRUFBRSxjQUF1QyxFQUFFLGFBQXFCO0lBQ3pJLE1BQU0sZ0JBQWdCLEdBQUcsY0FBYyxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsRUFBRSxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUE7SUFDeEYsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLEdBQUcsZ0JBQWdCLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQyxDQUFBO0lBRTdELE9BQU8sZ0JBQWdCLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUNoQyxNQUFNLFlBQVksR0FBRyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFBO1FBQ25ELE1BQU0sY0FBYyxDQUFDLFVBQVUsQ0FBQztZQUM1QixZQUFZLEVBQUU7Z0JBQ1YsQ0FBQyxhQUFhLENBQUMsRUFBRSxZQUFZLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDMUMsYUFBYSxFQUFFLEVBQUMsR0FBRyxFQUFFLEVBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxFQUFFLEVBQUMsRUFBQztpQkFDekMsQ0FBQyxDQUFDO2FBQ047U0FDSixDQUFDLENBQUMsT0FBTyxFQUFFLENBQUE7S0FDZjtBQUdMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0FQSUdhdGV3YXlQcm94eVJlc3VsdFYyfSBmcm9tICdhd3MtbGFtYmRhJztcbmltcG9ydCB7RHluYW1vREJ9IGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0IHtzb3J0QnlTdHJpbmdEZXNjfSBmcm9tIFwiLi4vLi4vdXRpbC9zb3J0XCI7XG5pbXBvcnQge1N0b3JlZE1lc3NhZ2VQcm9wc30gZnJvbSBcIi4uLy4uLy4uLy4uL2NvbW1vbi93ZWJzb2NrZXQtdHlwZXMvY2hhdC1tZXNzYWdlXCI7XG5cbmNvbnN0IE1BWF9NRVNTQUdFU19MSU1JVCA9IDMwXG5cbmV4cG9ydCBjb25zdCBoYW5kbGVyID0gYXN5bmMgKCk6IFByb21pc2U8QVBJR2F0ZXdheVByb3h5UmVzdWx0VjI+ID0+IHtcbiAgICBjb25zdCBtZXNzYWdlc1RhYmxlID0gcHJvY2Vzcy5lbnYuTUVTU0FHRVNfVEFCTEVfTkFNRSB8fCAoKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1lc3NhZ2VzIHRhYmxlIG5hbWUgc3VwcGxpZWQnKVxuICAgIH0pKClcbiAgICBjb25zb2xlLmxvZygnUXVlcnlpbmcgbWVzc2FnZXMnKTtcbiAgICBjb25zdCBkb2N1bWVudENsaWVudCA9IG5ldyBEeW5hbW9EQi5Eb2N1bWVudENsaWVudCgpO1xuICAgIGNvbnN0IGFsbE1lc3NhZ2VzID0gKGF3YWl0IGRvY3VtZW50Q2xpZW50LnNjYW4oe1RhYmxlTmFtZTogbWVzc2FnZXNUYWJsZX0pLnByb21pc2UoKSkuSXRlbXMgYXMgU3RvcmVkTWVzc2FnZVByb3BzW107XG4gICAgYWxsTWVzc2FnZXMuc29ydCgobWVzc2FnZUEsIG1lc3NhZ2VCKSA9PiBzb3J0QnlTdHJpbmdEZXNjKG1lc3NhZ2VBLnNlbnRBdCwgbWVzc2FnZUIuc2VudEF0KSlcbiAgICBsZXQgbWVzc2FnZXNUb1JldHVybjogU3RvcmVkTWVzc2FnZVByb3BzW11cbiAgICBpZiAoIWFsbE1lc3NhZ2VzKSB7XG4gICAgICAgIG1lc3NhZ2VzVG9SZXR1cm4gPSBbXVxuICAgIH0gZWxzZSBpZiAoYWxsTWVzc2FnZXMubGVuZ3RoID4gTUFYX01FU1NBR0VTX0xJTUlUKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdUbyBtYW55IG1lc3NhZ2VzIGluIHRhYmxlLCBkZWxldGluZyBzdXBlcmZsdW91cyBvbmVzJylcbiAgICAgICAgYXdhaXQgZGVsZXRlU3VwZXJmbHVvdXNNZXNzYWdlcyhhbGxNZXNzYWdlcywgZG9jdW1lbnRDbGllbnQsIG1lc3NhZ2VzVGFibGUpXG4gICAgICAgIG1lc3NhZ2VzVG9SZXR1cm4gPSBhbGxNZXNzYWdlcy5zbGljZSgwLCBNQVhfTUVTU0FHRVNfTElNSVQpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZXNUb1JldHVybiA9IGFsbE1lc3NhZ2VzXG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFJldHJpZXZlZCBsYXRlc3QgbWVzc2FnZXNgKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe21lc3NhZ2VzOiBtZXNzYWdlc1RvUmV0dXJufSksXG4gICAgICAgIGhlYWRlcnM6IHsnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJzogJyonfVxuICAgIH07XG5cbn1cblxuLyoqXG4gKiBEZWxldGVzIGFsbCBtZXNzYWdlcyBmcm9tIHRoZSB0YWJsZSB0aGF0IGV4Y2VlZCB0aGUgbGltaXQsIGxlYXZpbmcgb25seSB0aGUgbW9zdCByZWNlbnQgb25lc1xuICogQHBhcmFtIG1lc3NhZ2VzU29ydGVkIExpc3Qgb2YgYWxsIG1lc3NhZ2UgdGFibGUgcm93cywgc29ydGVkIGluIGRlc2NlbmRpbmcgb3JkZXIgYnkgc2VudEF0IHByb3BlcnR5XG4gKiBAcGFyYW0gZG9jdW1lbnRDbGllbnRcbiAqIEBwYXJhbSBtZXNzYWdlc1RhYmxlIHRhYmxlIG5hbWUgb2YgbWVzc2FnZXMgdGFibGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVsZXRlU3VwZXJmbHVvdXNNZXNzYWdlcyhtZXNzYWdlc1NvcnRlZDogU3RvcmVkTWVzc2FnZVByb3BzW10sIGRvY3VtZW50Q2xpZW50OiBEeW5hbW9EQi5Eb2N1bWVudENsaWVudCwgbWVzc2FnZXNUYWJsZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgbWVzc2FnZXNUb0RlbGV0ZSA9IG1lc3NhZ2VzU29ydGVkLnNsaWNlKE1BWF9NRVNTQUdFU19MSU1JVCwgbWVzc2FnZXNTb3J0ZWQubGVuZ3RoKVxuICAgIGNvbnNvbGUubG9nKCdEZWxldGluZyAnICsgbWVzc2FnZXNUb0RlbGV0ZS5sZW5ndGggKyAnIGl0ZW1zJylcblxuICAgIHdoaWxlIChtZXNzYWdlc1RvRGVsZXRlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgY3VycmVudEJhdGNoID0gbWVzc2FnZXNUb0RlbGV0ZS5zcGxpY2UoMCwgMjUpXG4gICAgICAgIGF3YWl0IGRvY3VtZW50Q2xpZW50LmJhdGNoV3JpdGUoe1xuICAgICAgICAgICAgUmVxdWVzdEl0ZW1zOiB7XG4gICAgICAgICAgICAgICAgW21lc3NhZ2VzVGFibGVdOiBjdXJyZW50QmF0Y2gubWFwKG1lc3NhZ2UgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgRGVsZXRlUmVxdWVzdDoge0tleToge2lkOiBtZXNzYWdlLmlkfX1cbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkucHJvbWlzZSgpXG4gICAgfVxuXG5cbn0iXX0=